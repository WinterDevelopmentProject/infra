name: Deploy (PROD)

on:
  repository_dispatch:
    types: [deploy-prod]

concurrency:
  group: deploy-game
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script_stop: true
          script: |
            set -euo pipefail
            set -x

            SERVICE="${{ github.event.client_payload.service }}"
            IMAGE="${{ github.event.client_payload.image }}"
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"

            echo "[deploy] service=${SERVICE}"
            echo "[deploy] image=${IMAGE}"
            echo "[deploy] user=$(whoami) host=$(hostname) home=${HOME}"

            [ -n "${SERVICE}" ] && [ -n "${IMAGE}" ]
            [ -d "${DEPLOY_PATH}" ]

            cd "${DEPLOY_PATH}"
            echo "[deploy] working_dir=$(pwd)"
            ls -la

            # ----------------------------
            # 1) (NEW) Ensure docker-compose.yml is the latest from infra repo main
            #    - DEPLOY_PATH must be a git clone of infra repo
            # ----------------------------
            if [ -d ".git" ]; then
              echo "[deploy] updating infra repo (git pull)"
              git remote -v || true
              git fetch --all --prune
              git reset --hard origin/main
              git clean -fd
            else
              echo "[deploy] WARN: ${DEPLOY_PATH} is not a git repo (.git missing). compose will NOT be updated."
              echo "[deploy]       If you want compose auto-update, DEPLOY_PATH must be a clone of the infra repo."
            fi

            # ----------------------------
            # 2) front.env (temporary)
            # ----------------------------
            echo "[deploy] create front.env"
            cat << 'EOF' > front.env
            PUBLIC_API_URL=${{ secrets.FRONT_PUBLIC_API_URL }}
            PUBLIC_WS_URL=${{ secrets.FRONT_PUBLIC_WS_URL }}
            EOF
            echo "[deploy] front.env created"

            export COMPOSE_PROJECT_NAME="game"
            ENV_FILE=".env"

            # ----------------------------
            # 3) Determine which service to update
            # ----------------------------
            if [ "${SERVICE}" = "frontend" ]; then
              echo "${IMAGE}" | grep -q "/svelteweb:"
              KEY="FRONT_IMAGE"
              SVC="sveltekit"
            elif [ "${SERVICE}" = "backend" ]; then
              echo "${IMAGE}" | grep -q "/gameserver:"
              KEY="BACK_IMAGE"
              SVC="api"
            else
              echo "[deploy] Unknown service: ${SERVICE}"
              exit 1
            fi

            # ----------------------------
            # 4) Update .env image tag
            # ----------------------------
            echo "[deploy] updating ${KEY} -> ${IMAGE}"
            if grep -q "^${KEY}=" "${ENV_FILE}"; then
              sed -i "s|^${KEY}=.*|${KEY}=${IMAGE}|" "${ENV_FILE}"
            else
              echo "${KEY}=${IMAGE}" >> "${ENV_FILE}"
            fi

            # ----------------------------
            # 5) (NEW) Validate docker compose config and show effective routers labels quick check
            # ----------------------------
            echo "[deploy] docker compose config check"
            docker compose --env-file "${ENV_FILE}" config >/dev/null

            echo "[deploy] sanity: show relevant traefik labels (resolved)"
            docker compose --env-file "${ENV_FILE}" config | sed -n '/services:/,$p' | egrep -n "traefik\.http\.routers\.game-(api|socket|front)\.|loadbalancer\.server\.port|stripprefix" || true

            # ----------------------------
            # 6) Pull & recreate ONLY the target service (no deps)
            # ----------------------------
            echo "[deploy] docker compose pull ${SVC}"
            docker compose --env-file "${ENV_FILE}" pull "${SVC}" || {
              echo "[deploy] pull failed. showing status/logs..."
              docker compose --env-file "${ENV_FILE}" ps || true
              docker compose --env-file "${ENV_FILE}" logs --no-color --tail=200 "${SVC}" || true
              exit 1
            }

            echo "[deploy] docker compose up -d --no-deps --force-recreate ${SVC}"
            docker compose --env-file "${ENV_FILE}" up -d --no-deps --force-recreate "${SVC}" || {
              echo "[deploy] up failed. showing status/logs..."
              docker compose --env-file "${ENV_FILE}" ps || true
              docker compose --env-file "${ENV_FILE}" logs --no-color --tail=200 "${SVC}" || true
              exit 1
            }

            # ----------------------------
            # 7) (NEW) Post-check: ensure containers are on proxy network and /api isn't falling through
            # ----------------------------
            echo "[deploy] done. ps:"
            docker compose --env-file "${ENV_FILE}" ps

            echo "[deploy] post-check: networks"
            docker inspect traefik --format 'traefik networks={{json .NetworkSettings.Networks}}' || true
            docker compose --env-file "${ENV_FILE}" ps -q sveltekit | xargs -r docker inspect --format 'sveltekit networks={{json .NetworkSettings.Networks}}' || true
            docker compose --env-file "${ENV_FILE}" ps -q api | xargs -r docker inspect --format 'api networks={{json .NetworkSettings.Networks}}' || true

            echo "[deploy] post-check: curl /api/health (expect backend)"
            curl -sk -o /dev/null -w "status=%{http_code}\n" "https://game.0x51018.com/api/health" || true

            docker image prune -f || true
